# Java Data Structures and Algorithms

This repository contains various data structures and algorithms implemented in Java. Each implementation is provided with explanations and examples where applicable.
(not yet completed)
## Table of Contents

1. [Introduction](#introduction)
2. [Data Structures](#data-structures)
    - [1. Array](#array)
    - [2. Linked List](#linked-list)
    - [3. Stack](#stack)
    - [4. Queue](#queue)
    - [5. Binary Tree](#binary-tree)
    - [6. Graph](#graph)
    - [7. HashMap](#hashmap)
    - [8. HashSet](#hashset)
    - [9. PriorityQueue](#priorityqueue)
3. [Algorithms](#algorithms)
    - [1. Sorting Algorithms](#sorting-algorithms)
    - [2. Searching Algorithms](#searching-algorithms)
    - [3. Graph Algorithms](#graph-algorithms)
    - [4. Dynamic Programming](#dynamic-programming)
    - [5. Recursion](#recursion)

## Introduction

This repository serves as a collection of Java implementations of common data structures and algorithms. It aims to provide a resource for developers to understand and learn about these fundamental concepts through practical examples.

## Data Structures

### 1. Array

- Implementation of dynamic array.
- Operations: insert, delete, access.
- Example usage: dynamic array for storing elements of varying sizes.

### 2. Linked List

- Implementation of singly linked list, doubly linked list, and circular linked list.
- Operations: insert, delete, search.
- Example usage: linked list for dynamic memory allocation.

### 3. Stack

- Implementation of stack using array and linked list.
- Operations: push, pop, peek, isEmpty.
- Example usage: expression evaluation, backtracking.

### 4. Queue

- Implementation of queue using array and linked list.
- Operations: enqueue, dequeue, isEmpty.
- Example usage: scheduling tasks, breadth-first search.

### 5. Binary Tree

- Implementation of binary tree and binary search tree.
- Operations: insert, delete, search, traversal (in-order, pre-order, post-order).
- Example usage: hierarchical data representation, sorting.

### 6. Graph

- Implementation of graph using adjacency matrix and adjacency list.
- Operations: add vertex, add edge, traverse.
- Example usage: network analysis, shortest path algorithms.

### 7. HashMap

- Implementation of hash map.
- Operations: put, get, remove, containsKey.
- Example usage: associative arrays, caching.

### 8. HashSet

- Implementation of hash set.
- Operations: add, remove, contains.
- Example usage: set operations, duplicate elimination.

### 9. PriorityQueue

- Implementation of priority queue using binary heap.
- Operations: insert, delete, getMin/getMax.
- Example usage: task scheduling, Dijkstra's algorithm.

## Algorithms

### 1. Sorting Algorithms

- Implementation of popular sorting algorithms: bubble sort, selection sort, insertion sort, merge sort, quick sort, heap sort.
- Example usage: sorting arrays, searching in sorted arrays.

### 2. Searching Algorithms

- Implementation of searching algorithms: linear search, binary search.
- Example usage: finding elements in arrays, database querying.

### 3. Graph Algorithms

- Implementation of graph algorithms: breadth-first search (BFS), depth-first search (DFS), Dijkstra's algorithm, Bellman-Ford algorithm, Floyd-Warshall algorithm, Kruskal's algorithm, Prim's algorithm.
- Example usage: path finding, network analysis, minimum spanning tree.

### 4. Dynamic Programming

- Implementation of dynamic programming algorithms: Fibonacci sequence, longest common subsequence, knapsack problem, matrix chain multiplication.
- Example usage: optimization problems, sequence alignment.

### 5. Recursion

- Implementation of recursive algorithms: factorial, Fibonacci sequence, Tower of Hanoi.
- Example usage: problems with recursive structure, tree traversal.
